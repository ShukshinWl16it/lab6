# Шукшин Владимир_ИТ-16_лаб_№4

# Вариант 6
## Задание 1
Аннотации
### Задача 1
Текст задачи
@Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные
аннотацией @Invoke, и вызывает их автоматически.
### Алгоритм решения
Создаем маркерную аннотацию @Invoke с целевым типом ElementType.METHOD и политикой удержания RetentionPolicy.RUNTIME.
Разрабатываем класс-обработчик, который с помощью Reflection API (getDeclaredMethods(), isAnnotationPresent()) находит все методы переданного объекта, помеченные этой аннотацией.
Делает их доступными при необходимости (setAccessible(true)) и вызывает (method.invoke(object)), обрабатывая возможные исключения.
Создаем тестовый класс с несколькими методами, помечая аннотацией @Invoke для демонстрации работы.

<img width="211" height="127" alt="image" src="https://github.com/user-attachments/assets/3aa64116-94b0-4ece-ade3-e729804e2c54" />

### Задача 2
Текст задачи
@Default.
Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.
### Алгоритм решения
Создаем аннотацию @Default с областью применения для типов и полей (ElementType.TYPE, ElementType.FIELD) и политикой удержания RetentionPolicy.RUNTIME.
Добавляем обязательный параметр Class<?> value().
Разрабатываем тестовый класс. Реализовываем обработчик, который через Reflection API (getClass(), getAnnotation(Default.class)) извлекает аннотацию из переданного объекта.
Проверяет её наличие и выводит имя класса, указанного в параметре value().

<img width="687" height="68" alt="image" src="https://github.com/user-attachments/assets/3e9433d2-8472-482a-93a0-31319ecf3610" />

### Задача 3
Текст задачи
@ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES.
### Алгоритм решения
Реализована аннотация @ToString для управления формированием строкового представления объектов.
Аннотация применяется к классам и полям, использует Mode.YES (включить) и Mode.NO (исключить). 
Метод generateToString(Object object) в классе ToStringReflection анализирует объект: получает его класс и поля, проверяет аннотации, формирует строку.
Приватные поля становятся доступными через setAccessible(true). 
Если класс не аннотирован или имеет Mode.YES, включаются все поля, кроме помеченных Mode.NO.

<img width="562" height="95" alt="image" src="https://github.com/user-attachments/assets/ed8b6c19-461a-4b14-bc47-8f0cfdf3440d" />

### Задача 4
Текст задачи
@Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.
### Алгоритм решения
Создана аннотация @Validate для указания связанных классов проверки. 
Класс ValidateReflection с методом showValidation() анализирует объект, проверяет наличие аннотации @Validate. 
При её отсутствии или пустом массиве классов выбрасывается IllegalArgumentException. 
Выводит названия всех указанных в аннотации классов.

<img width="282" height="113" alt="image" src="https://github.com/user-attachments/assets/225bc3c1-fa00-467a-a2de-dd5a69382d57" />

### Задача 5
Текст задачи
@Two.
Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.
### Алгоритм решения
Разработана аннотация @Two для хранения двух значений (строки и числа) над классом.
Класс TwoReflection с методом ShowTwo() получает аннотацию @Two из класса объекта и выводит значения first и second в консоль.

<img width="276" height="94" alt="image" src="https://github.com/user-attachments/assets/dfb3038c-bb64-4c85-88b4-69c861d24557" />

### Задача 6
Текст задачи
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.
### Алгоритм решения
Создана аннотация @Cache для указания кэшируемых областей класса. 
Класс CacheReflection с методом showCache() проверяет наличие аннотации @Cache, при отсутствии или пустом списке областей выбрасывается IllegalArgumentException. 
Выводит названия всех указанных кэшируемых областей.

<img width="370" height="70" alt="image" src="https://github.com/user-attachments/assets/0ff417de-8774-4993-83ef-6e45da0a2fc2" />

## Задание 2
Тестирование
### Задача 1
Текст задачи
Напишите тест, используя фреймворк JUnit, к методу toString() (или методу, формирующему
строковое представление объекта, основанное на аннотации @ToString).
• Проверить, что в результирующей строке отображаются только те поля, которые имеют
аннотацию @ToString(Mode.YES) или не аннотированы вовсе.
• Убедиться, что поля с @ToString(Mode.NO) не попадают в вывод
### Алгоритм решения
Создаем аннотацию @ToString с параметром Mode (YES/NO), применяемую к полям и доступную в runtime.
Разрабатываем класс (Book) с полями, помеченными разными режимами аннотации.
Реализовываем в нём метод toString(), который с помощью Reflection API (getDeclaredFields(), getAnnotation(ToString.class)) собирает строковое представление,
включая только поля с Mode.YES или без аннотации (как YES), и исключая поля с Mode.NO.
Пишем JUnit-тесты: создаем объект тестового класса, вызываем toString().
С помощью assertTrue()/assertFalse() проверяем, что в результирующей строке присутствуют значения и названия полей с Mode.YES (или без аннотации) и отсутствуют поля с Mode.NO.

<img width="644" height="100" alt="image" src="https://github.com/user-attachments/assets/1743cb16-8e00-4525-9c4b-021f47c37242" />

### Задача 4
Текст задачи
Написать тест, используя фреймворк JUnit, который проверяет корректность работы механизма
валидации классов, отмеченных аннотацией @Validate.
• Создать класс с аннотацией @Validate, указывающей массив типов для проверки.
• Использовать тест, который вызывает обработчик и проверяет, что список классов,
переданный в аннотации, корректно извлекается и при передаче пустого массива
выбрасывается исключение IllegalArgumentException.
• В тесте использовать аннотацию @Test с параметром expected (или assertThrows в JUnit 5)
### Алгоритм решения
Пишем JUnit-тесты: с захватом вывода (ByteArrayOutputStream) проверить корректный вывод типов при непустом массиве.
С @Test(expected = IllegalArgumentException.class) проверить генерацию исключений для пустого массива и отсутствия аннотации.
С try-catch и assertEquals() проверить точное сообщение исключения.

<img width="674" height="142" alt="image" src="https://github.com/user-attachments/assets/da163bbf-460a-4ace-a0ad-c35ebdb60517" />
